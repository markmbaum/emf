from .. import np, _quad

#magnetic permeability constant, in SI units
MU_0 = 4*np.pi*1e-7
#convenient constant, converted for mG
magnetic_prefactor = 1.0e7*MU_0/(4.*np.pi)

def _B_integral(t, xp, yp, zp, delta_x, delta_y, delta_z, xa, ya, za):
    return(
        (
            (xp - t*delta_x - xa)**2
            + (yp - t*delta_y - ya)**2
            + (zp - t*delta_z - za)**2
        )**(-3./2.)
    )

def B_field_segment(a, b, I, ph, x, y, z):
    """Calculate the magnetic field generated by a current carrying segment
    of wire in three dimensions
    args:
        a - 1D numpy array containing the x,y,z coordinates of the beginning
            of the wire segment (ft)
        b - 1D numpy array containing the x,y,z coordinates of the end
            of the wire segment (ft)
        I - float, the current of the wire segment (Amps)
        ph - float, the phase of the current (degrees)
        x - 1D numpy array, x coordinates of sample points (ft)
        y - 1D numpy array, y coordinates of sample points (ft)
        z - 1D numpy array, z coordinates of sample points (ft)
    returns:
        Bx - 3D numpy array of complex numbers, magnetic field phasors in
             the x direction
        By - 3D numpy array of complex numbers, magnetic field phasors in
             the y direction
        Bz - 3D numpy array of complex numbers, magnetic field phasors in
             the z direction

            note:   the 3D arrays returned use the 'xy' indexing convention:
                        - the 0th axis corresponds to y coordinates, with the
                            order of the input y coordinates reversed
                        - the 1st axis corresponds to x coordinates
                        - the 2nd axis cooresponds to z coordinates, with the
                            order of the input y coordinates reversed

                    B[0,0,0] would coorespond to the top, back, and left corner
                    of the results if the results were laid out in a cube.
                    B[-1,-1,-1] would be to the lower, front, and right corner"""

    #array length variables
    Nx, Ny, Nz = len(x), len(y), len(z)
    rx, ry, rz = range(Nx), range(Ny), range(Nz)

    #conversions
    a = a*0.3048            #convert to meters
    b = b*0.3048            #convert to meters
    x = x*0.3048            #convert to meters
    y = y*0.3048            #convert to meters
    z = z*0.3048            #convert to meters
    ph = ph*2*np.pi/360     #convert to radians

    #pull out the coordinates of the starting and ending point of the wire
    xa, ya, za = a
    xb, yb, zb = b

    #store the differences bewteen each dimension's coordinates
    delta_x = xb - xa
    delta_y = yb - ya
    delta_z = zb - za

    #convert the current and phase into a complex phasor
    I = I*(np.cos(ph) + complex(0,1)*np.sin(ph))

    #compute magnetic field component phasors for each x,y,z point
    Bx = np.empty((Ny, Nx, Nz), dtype=complex)
    By = np.empty((Ny, Nx, Nz), dtype=complex)
    Bz = np.empty((Ny, Nx, Nz), dtype=complex)
    for i in rx:
        for j in ry:
            for k in rz:
                #sample point
                xp, yp, zp = x[i], y[j], z[k]
                #dB, essentially the numerator
                fac = np.array([delta_y*(zp - za) + delta_z*(ya - yp),
                        delta_z*(xp - xa) + delta_x*(za - zp),
                        delta_x*(yp - ya) + delta_y*(xa - xp)])
                #integral evaluation
                args = (xp, yp, zp, delta_x, delta_y, delta_z, xa, ya, za)
                integral = _quad(_B_integral, 0, 1, args)
                #all together now (vector of phasor components with units)
                B = magnetic_prefactor*I*fac*integral[0]
                #indices to store the result in
                idx = Ny-j-1, i, Nz-k-1
                #store the result
                Bx[idx], By[idx], Bz[idx] = B

    return(Bx, By, Bz)


def phasors_to_magnitudes(Ph_x, Ph_y, Ph_z):
    """Convert vectors of complex x and y phasors into real quantities, namely the amplitude of the field in the x and y directions, the product (the hypotenuse of the amplitudes), and the maximum field
    args:
        Ph_x - complex 1D numpy array, phasor x components
        Ph_y - complex 1D numpy array, phasor y components
        Ph_z - complex 1D numpy array, phasor z components
    returns:
        mag_x - 1D numpy array, maximum x field
        mag_y - 1D numpy array, maximum y field
        mag_z - 1D numpy array, maximum z field
        prod - 1D numpy array, sqrt(mag_x**2 + mag_y**2)
        maximum - 1D numpy array, maximum field at any time"""

    #amplitude along each component, storing squared magnitudes for later
    mag_x_sq = np.real(Ph_x)**2 + np.imag(Ph_x)**2
    mag_x = np.sqrt(mag_x_sq)
    mag_y_sq = np.real(Ph_y)**2 + np.imag(Ph_y)**2
    mag_y = np.sqrt(mag_y_sq)
    mag_z_sq = np.real(Ph_z)**2 + np.imag(Ph_z)**2
    mag_z = np.sqrt(mag_z_sq)

    #phase angle of each component
    phase_x = np.arctan2(np.imag(Ph_x), np.real(Ph_x))
    phase_y = np.arctan2(np.imag(Ph_y), np.real(Ph_y))
    phase_z = np.arctan2(np.imag(Ph_z), np.real(Ph_z))

    #"product"
    prod = np.sqrt(mag_x**2 + mag_y**2 + mag_z**2)

    #maximum resultant value found by setting the time derivative of the
    #squared resultant magnitude to zero (Appendix 8.1 EPRI's "Big Red Book")
    num = (mag_x_sq*np.sin(2*phase_x)
            + mag_y_sq*np.sin(2*phase_y)
            + mag_z_sq*np.sin(2*phase_z))
    den = (mag_x_sq*np.cos(2*phase_x)
            + mag_y_sq*np.cos(2*phase_y)
            + mag_z_sq*np.cos(2*phase_z))
    t1 = (0.5)*np.arctan2(-num, den)
    t2 = t1 + np.pi/2
    x_term = mag_x_sq*(np.cos(t1 + phase_x))**2
    y_term = mag_y_sq*(np.cos(t1 + phase_y))**2
    z_term = mag_z_sq*(np.cos(t1 + phase_z))**2
    ax_mag1 = np.sqrt(x_term + y_term + z_term)
    x_term = mag_x_sq*(np.cos(t2 + phase_x))**2
    y_term = mag_y_sq*(np.cos(t2 + phase_y))**2
    z_term = mag_z_sq*(np.cos(t2 + phase_z))**2
    ax_mag2 = np.sqrt(x_term + y_term + z_term)

    #pick out the semi-major axis magnitude from the two semi-axis results
    maximum = np.maximum(ax_mag1, ax_mag2)

    #return the 4 output columns
    return(mag_x, mag_y, mag_z, prod, maximum)
