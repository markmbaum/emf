from .. import os, np, ctypes

#magnetic permeability constant, in SI units
MU_0 = 4*np.pi*1e-7
#convenient constant, converted for mG
magnetic_prefactor = 1.0e7*MU_0/(4.*np.pi)

#laod C functions in the lift module
fn = os.path.join(os.path.dirname(__file__), 'lift', 'lift.so')
lift = ctypes.cdll.LoadLibrary(fn)

def B_field_segment(a, b, I, ph, x, y, z):
    """Calculate the magnetic field generated by a current carrying segment of wire in three dimensions
    args:
        a - 1D numpy array containing the x,y,z coordinates of the beginning
            of the wire segment (ft)
        b - 1D numpy array containing the x,y,z coordinates of the end
            of the wire segment (ft)
        I - float, the current of the wire segment (Amps)
        ph - float, the phase of the current (degrees)
        x - 1D numpy array, sorted x coordinates of sample grid (ft)
        y - 1D numpy array, sorted y coordinates of sample grid (ft)
        z - float, the sample height (ft)
    returns:
        Ph_x - 1D numpy array of complex numbers, magnetic field phasors in
               the x direction
        Ph_y - 1D numpy array of complex numbers, magnetic field phasors in
               the y direction
        Ph_z - 1D numpy array of complex numbers, magnetic field phasors in
               the z direction

            note: The 1D arrays returned are flat/1D because flat arrays are
                    simpler to work on with C code. Use the grid_segment_results
                    function to convert the flat arrays into more usable
                    2D arrays."""

    #wrap the single z value in an array for the c functions, which are
    #fully 3D
    z = np.array([z], dtype=float)

    #conversions
    a = a*0.3048            #convert to meters
    b = b*0.3048            #convert to meters
    x = x*0.3048            #convert to meters
    y = y*0.3048            #convert to meters
    z = z*0.3048            #convert to meters
    ph = ph*2*np.pi/360     #convert to radians

    #pull out the coordinates of the starting and ending point of the wire
    xa, ya, za = a
    xb, yb, zb = b

    #store the differences bewteen each dimension's coordinates
    delta_x = xb - xa
    delta_y = yb - ya
    delta_z = zb - za

    #convert the current and phase into a complex phasor
    I = I*(np.cos(ph) + complex(0,1)*np.sin(ph))

    #use the functions in lift.c to do the heavy computational lifting of
    #these calculations, which are mostly made heavy by the path integral
    N = len(x)*len(y)
    fac_x = np.empty((N,), dtype=np.double)
    fac_y = np.empty((N,), dtype=np.double)
    fac_z = np.empty((N,), dtype=np.double)
    integral = np.empty((N,), dtype=np.double)
    c_double_ptr = ctypes.POINTER(ctypes.c_double)
    lift.lift(x.ctypes.data_as(c_double_ptr),
            y.ctypes.data_as(c_double_ptr),
            z.ctypes.data_as(c_double_ptr),
            ctypes.c_double(delta_x),
            ctypes.c_double(delta_y),
            ctypes.c_double(delta_z),
            ctypes.c_double(xa),
            ctypes.c_double(ya),
            ctypes.c_double(za),
            ctypes.c_long(len(x)),
            ctypes.c_long(len(y)),
            ctypes.c_long(1), #there is only 1 z value
            fac_x.ctypes.data_as(c_double_ptr),
            fac_y.ctypes.data_as(c_double_ptr),
            fac_z.ctypes.data_as(c_double_ptr),
            integral.ctypes.data_as(c_double_ptr))

    #carry through with the rest of the calculations
    con = magnetic_prefactor*I*(integral.astype(complex))
    Ph_x = fac_x*con
    Ph_y = fac_y*con
    Ph_z = fac_z*con

    return(Ph_x, Ph_y, Ph_z)

def grid_segment_results(Ph_x, Ph_y, Ph_z, x, y):
    """Convert the flat arrays returned by B_field_segment into 2D arrays
    args:
        Ph_x - complex 1D numpy array representing phasors in the x direction
        Ph_y - complex 1D numpy array representing phasors in the y direction
        Ph_z - complex 1D numpy array representing phasors in the z direction
        x - 1D numpy array, sorted x coordinates of sample grid (ft)
        y - 1D numpy array, sorted y coordinates of sample grid (ft)
    returns:
        Ph_x_grid - complex 2D numpy array, phasors in the x direction
        Ph_y_grid - complex 2D numpy array, phasors in the y direction
        Ph_z_grid - complex 2D numpy array, phasors in the z direction
        X - 2D array containing x coordinates of the sample grid
        Y - 2D array containing y coordinates of the sample grid"""

    Nx, Ny = len(x), len(y)
    Ph_x_grid = np.flipud(np.reshape(Ph_x, (Ny, Nx)))
    Ph_y_grid = np.flipud(np.reshape(Ph_y, (Ny, Nx)))
    Ph_z_grid = np.flipud(np.reshape(Ph_z, (Ny, Nx)))
    X, Y = np.meshgrid(x, y[::-1], indexing='xy')

    return(Ph_x_grid, Ph_y_grid, Ph_z_grid, X, Y)

def phasors_to_magnitudes(Ph_x, Ph_y, Ph_z):
    """Convert vectors of complex x, y, and z phasors into real quantities, namely the amplitude of the field in the x, y, and z directions, the product/resultant (the hypotenuse of the amplitudes), and the time-dependent maximum field
    args:
        Ph_x - complex 3D numpy array, phasor x components
        Ph_y - complex 3D numpy array, phasor y components
        Ph_z - complex 3D numpy array, phasor z components
    returns:
        mag_x - 3D numpy array, maximum x field
        mag_y - 3D numpy array, maximum y field
        mag_z - 3D numpy array, maximum z field
        prod - 3D numpy array, sqrt(mag_x**2 + mag_y**2)
        maximum - 3D numpy array, maximum field at any time"""

    #amplitude along each component, storing squared magnitudes for later
    mag_x_sq = np.real(Ph_x)**2 + np.imag(Ph_x)**2
    mag_x = np.sqrt(mag_x_sq)
    mag_y_sq = np.real(Ph_y)**2 + np.imag(Ph_y)**2
    mag_y = np.sqrt(mag_y_sq)
    mag_z_sq = np.real(Ph_z)**2 + np.imag(Ph_z)**2
    mag_z = np.sqrt(mag_z_sq)

    #phase angle of each component
    phase_x = np.arctan2(np.imag(Ph_x), np.real(Ph_x))
    phase_y = np.arctan2(np.imag(Ph_y), np.real(Ph_y))
    phase_z = np.arctan2(np.imag(Ph_z), np.real(Ph_z))

    #"product"
    prod = np.sqrt(mag_x**2 + mag_y**2 + mag_z**2)

    #maximum resultant value found by setting the time derivative of the
    #squared resultant magnitude to zero (Appendix 8.1 EPRI's "Big Red Book")
    num = (mag_x_sq*np.sin(2*phase_x)
            + mag_y_sq*np.sin(2*phase_y)
            + mag_z_sq*np.sin(2*phase_z))
    den = (mag_x_sq*np.cos(2*phase_x)
            + mag_y_sq*np.cos(2*phase_y)
            + mag_z_sq*np.cos(2*phase_z))
    t1 = (0.5)*np.arctan2(-num, den)
    t2 = t1 + np.pi/2
    x_term = mag_x_sq*(np.cos(t1 + phase_x))**2
    y_term = mag_y_sq*(np.cos(t1 + phase_y))**2
    z_term = mag_z_sq*(np.cos(t1 + phase_z))**2
    ax_mag1 = np.sqrt(x_term + y_term + z_term)
    x_term = mag_x_sq*(np.cos(t2 + phase_x))**2
    y_term = mag_y_sq*(np.cos(t2 + phase_y))**2
    z_term = mag_z_sq*(np.cos(t2 + phase_z))**2
    ax_mag2 = np.sqrt(x_term + y_term + z_term)

    #pick out the semi-major axis magnitude from the two semi-axis results
    maximum = np.maximum(ax_mag1, ax_mag2)

    #return the 4 output columns
    return(mag_x, mag_y, mag_z, prod, maximum)
