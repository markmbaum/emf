from .. import np, _quad

#magnetic permeability constant, in SI units
MU_0 = 4*np.pi*1e-7
#convenient constant, converted for mG
magnetic_prefactor = 1.0e7*MU_0/(4.*np.pi)

def _B_integral_lim_eval(t, t_sq, xp, yp, zp, delta_x, delta_y, delta_z,
        xa, ya, za, delta_x_sq, delta_y_sq, delta_z_sq,
        xa_sq, ya_sq, za_sq, xp_sq, yp_sq, zp_sq):

    return(
       (
           delta_x_sq*t + delta_x*(xa - xp) + delta_y_sq*t + delta_y*(ya - yp)
           + delta_z*(delta_z*t + za - zp)
       )/(
           (
               delta_x_sq*(ya_sq - 2*ya*yp + za_sq
               - 2*za*zp + yp_sq + zp_sq) - 2*xa*(delta_x*(delta_y*ya - delta_y*yp
               + delta_z*za - delta_z*zp) + xp*(delta_y_sq + delta_z_sq))
               + 2*delta_x*xp*(delta_y*ya - delta_y*yp + delta_z*za - delta_z*zp)
               + xa_sq*(delta_y_sq + delta_z_sq) + delta_y_sq*za_sq
               - 2*delta_y_sq*za*zp + delta_y_sq*xp_sq + delta_y_sq*zp_sq
               - 2*delta_y*ya*delta_z*za + 2*delta_y*ya*delta_z*zp
               + 2*delta_y*delta_z*za*yp - 2*delta_y*delta_z*yp*zp
               + ya_sq*delta_z_sq - 2*ya*delta_z_sq*yp + delta_z_sq*xp_sq
               + delta_z_sq*yp_sq
           )*np.sqrt(
               delta_x_sq*t_sq + 2*delta_x*xa*t - 2*delta_x*t*xp + xa_sq - 2*xa*xp +
               delta_y_sq*t_sq + 2*delta_y*ya*t - 2*delta_y*t*yp + ya_sq - 2*ya*yp +
               delta_z_sq*t_sq + 2*delta_z*za*t - 2*delta_z*t*zp + za_sq - 2*za*zp +
               xp_sq + yp_sq + zp_sq
           )
       )
   )

def _B_integral(t1, t2, xp, yp, zp, delta_x, delta_y, delta_z, xa, ya, za):

    delta_x_sq = delta_x**2
    delta_y_sq = delta_y**2
    delta_z_sq = delta_z**2

    xa_sq = xa**2
    ya_sq = ya**2
    za_sq = za**2

    xp_sq = xp**2
    yp_sq = yp**2
    zp_sq = zp**2

    eval2 = _B_integral_lim_eval(t2, t2**2, xp, yp, zp, delta_x, delta_y, delta_z,
            xa, ya, za, delta_x_sq, delta_y_sq, delta_z_sq,
            xa_sq, ya_sq, za_sq, xp_sq, yp_sq, zp_sq)

    eval1 = _B_integral_lim_eval(t1, t1**2, xp, yp, zp, delta_x, delta_y, delta_z,
            xa, ya, za, delta_x_sq, delta_y_sq, delta_z_sq,
            xa_sq, ya_sq, za_sq, xp_sq, yp_sq, zp_sq)

    return(eval2 - eval1)

def B_field_segment(a, b, I, ph, x, y, z):
    """Calculate the magnetic field generated by a current carrying segment
    of wire in three dimensions
    args:
        a - 1D numpy array containing the x,y,z coordinates of the beginning
            of the wire segment (ft)
        b - 1D numpy array containing the x,y,z coordinates of the end
            of the wire segment (ft)
        I - float, the current of the wire segment (Amps)
        ph - float, the phase of the current (degrees)
        x - 1D numpy array, x coordinates of sample points (ft)
        y - 1D numpy array, y coordinates of sample points (ft)
        z - 1D numpy array, z coordinates of sample points (ft)
    returns:
        Bx - 3D numpy array of complex numbers, magnetic field phasors in
             the x direction
        By - 3D numpy array of complex numbers, magnetic field phasors in
             the y direction
        Bz - 3D numpy array of complex numbers, magnetic field phasors in
             the z direction

            note:   the 3D arrays returned use the 'xy' indexing convention:
                        - the 0th axis corresponds to y coordinates, with the
                            order of the input y coordinates reversed
                        - the 1st axis corresponds to x coordinates
                        - the 2nd axis cooresponds to z coordinates, with the
                            order of the input y coordinates reversed

                    B[0,0,0] would coorespond to the top, back, and left corner
                    of the results if the results were laid out in a cube.
                    B[-1,-1,-1] would be to the lower, front, and right corner"""

    #array length variables
    Nx, Ny, Nz = len(x), len(y), len(z)
    rx, ry, rz = range(Nx), range(Ny), range(Nz)

    #conversions
    a = a*0.3048            #convert to meters
    b = b*0.3048            #convert to meters
    x = x*0.3048            #convert to meters
    y = y*0.3048            #convert to meters
    z = z*0.3048            #convert to meters
    ph = ph*2*np.pi/360     #convert to radians

    #pull out the coordinates of the starting and ending point of the wire
    xa, ya, za = a
    xb, yb, zb = b

    #store the differences bewteen each dimension's coordinates
    delta_x = xb - xa
    delta_y = yb - ya
    delta_z = zb - za

    #convert the current and phase into a complex phasor
    I = I*(np.cos(ph) + complex(0,1)*np.sin(ph))

    #compute magnetic field component phasors for each x,y,z point
    Bx = np.empty((Ny, Nx, Nz), dtype=complex)
    By = np.empty((Ny, Nx, Nz), dtype=complex)
    Bz = np.empty((Ny, Nx, Nz), dtype=complex)
    for i in rx:
        for j in ry:
            for k in rz:
                #sample point
                xp, yp, zp = x[i], y[j], z[k]
                #dB, essentially the numerator
                fac = np.array([delta_y*(zp - za) + delta_z*(ya - yp),
                        delta_z*(xp - xa) + delta_x*(za - zp),
                        delta_x*(yp - ya) + delta_y*(xa - xp)])
                #integral evaluation
                args = (xp, yp, zp, delta_x, delta_y, delta_z, xa, ya, za)
                integral = _B_integral(0, 1, xp, yp, zp, delta_x, delta_y, delta_z, xa, ya, za)
                #all together now (vector of phasor components with units)
                B = magnetic_prefactor*I*fac*integral
                #indices to store the result in
                idx = Ny-j-1, i, Nz-k-1
                #store the result
                Bx[idx], By[idx], Bz[idx] = B

    return(Bx, By, Bz)


def phasors_to_magnitudes(Ph_x, Ph_y, Ph_z):
    """Convert vectors of complex x and y phasors into real quantities, namely the amplitude of the field in the x and y directions, the product (the hypotenuse of the amplitudes), and the maximum field
    args:
        Ph_x - complex 1D numpy array, phasor x components
        Ph_y - complex 1D numpy array, phasor y components
        Ph_z - complex 1D numpy array, phasor z components
    returns:
        mag_x - 1D numpy array, maximum x field
        mag_y - 1D numpy array, maximum y field
        mag_z - 1D numpy array, maximum z field
        prod - 1D numpy array, sqrt(mag_x**2 + mag_y**2)
        maximum - 1D numpy array, maximum field at any time"""

    #amplitude along each component, storing squared magnitudes for later
    mag_x_sq = np.real(Ph_x)**2 + np.imag(Ph_x)**2
    mag_x = np.sqrt(mag_x_sq)
    mag_y_sq = np.real(Ph_y)**2 + np.imag(Ph_y)**2
    mag_y = np.sqrt(mag_y_sq)
    mag_z_sq = np.real(Ph_z)**2 + np.imag(Ph_z)**2
    mag_z = np.sqrt(mag_z_sq)

    #phase angle of each component
    phase_x = np.arctan2(np.imag(Ph_x), np.real(Ph_x))
    phase_y = np.arctan2(np.imag(Ph_y), np.real(Ph_y))
    phase_z = np.arctan2(np.imag(Ph_z), np.real(Ph_z))

    #"product"
    prod = np.sqrt(mag_x**2 + mag_y**2 + mag_z**2)

    #maximum resultant value found by setting the time derivative of the
    #squared resultant magnitude to zero (Appendix 8.1 EPRI's "Big Red Book")
    num = (mag_x_sq*np.sin(2*phase_x)
            + mag_y_sq*np.sin(2*phase_y)
            + mag_z_sq*np.sin(2*phase_z))
    den = (mag_x_sq*np.cos(2*phase_x)
            + mag_y_sq*np.cos(2*phase_y)
            + mag_z_sq*np.cos(2*phase_z))
    t1 = (0.5)*np.arctan2(-num, den)
    t2 = t1 + np.pi/2
    x_term = mag_x_sq*(np.cos(t1 + phase_x))**2
    y_term = mag_y_sq*(np.cos(t1 + phase_y))**2
    z_term = mag_z_sq*(np.cos(t1 + phase_z))**2
    ax_mag1 = np.sqrt(x_term + y_term + z_term)
    x_term = mag_x_sq*(np.cos(t2 + phase_x))**2
    y_term = mag_y_sq*(np.cos(t2 + phase_y))**2
    z_term = mag_z_sq*(np.cos(t2 + phase_z))**2
    ax_mag2 = np.sqrt(x_term + y_term + z_term)

    #pick out the semi-major axis magnitude from the two semi-axis results
    maximum = np.maximum(ax_mag1, ax_mag2)

    #return the 4 output columns
    return(mag_x, mag_y, mag_z, prod, maximum)
