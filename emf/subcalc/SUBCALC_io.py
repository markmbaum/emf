from .. import os, np

import subcalc_funks
import subcalc_class

def read_INP(file_path):
    """Read a formatted SUBCALC file containing model input information and convert it to a list of emf.subcalc Tower objects. The target file must have an INP extension. These files are generated by the "Output > Ascii > Input Data" function in the SUBCALC program.
    args:
        file_path - string, path to the target INP file
    returns:
        a list of Towers"""

    #check extension
    file_path = subcalc_funks._check_extension(file_path, 'INP',
            'Target file must have an "INP" extension.')

    info = {}
    with open(file_path, 'r') as ifile:
        line = ifile.readline()
        #collect info
        while('Label:' not in line):
            if((':' in line) and ('World' not in line)):
                idx = line.index(':')
                info[line[:idx]] = line[idx+1:]
            line = ifile.readline()
        towers = []
        #read to the end of the file, collecting Towers
        while(line != ''):

            if('Label:' in line):
                #pull the group name for the tower group
                group = line[line.index(':')+1:].strip()[1:-1].replace('#','')
                #advance to the numbers
                while(not subcalc_funks._is_number(line[:5])):
                    line = ifile.readline()
                #now read to the end of the tower group, moving through the data
                seq, x, y, rot = None, None, None, None
                h, v, I, phase = [], [], [], []

                while(line[:6] != '______'):
                    #split the line
                    s = line.strip().split()
                    #check if the line defines tower seqence, x, y, and rot
                    if((len(s) == 4) or (len(s) == 5)):
                        #store previous tower if there is one and clear vars
                        if(seq is not None):
                            towers.append(subcalc_class.Tower(
                                    group, seq, x, y, rot, h, v, I, phase))
                            h, v, I, phase = [], [], [], []
                        #grab new tower info
                        seq, x, y, rot = [float(i) for i in s][:4]
                        rot -= 90

                    elif(len(s) == 6):
                        #wire information
                        d = [float(i) for i in s[-4:]]
                        h.append(d[0])
                        v.append(d[1])
                        I.append(d[2])
                        phase.append(d[3])

                    line = ifile.readline()

                #store the last Tower
                if(seq is not None):
                    towers.append(subcalc_class.Tower(
                            group, seq, x, y, rot, h, v, I, phase))

            line = ifile.readline()

        return(towers)

def convert_REF(*args, **kw):
    """Convert a .REF results file to an excel file storing the same data and save the excel file
    args:
        REF_path - string, path to the .REF file
        footprint_path - string, optional, path to footprint csv file
    kw:
        path - string, path/name of output file"""

    #load and export the results
    load_results(*args, **kw).export(**kw)

def read_REF(file_path):
    """Reads a .REF output file generated by the SUBCALC program, pulling out x and y coordinates for the results and all the magnetic field "components"
    args:
        file_path - string, path to saved .REF output file
    returns:
        data - dict, keys are 'x', 'y', 'Bmax', 'Bres', 'Bx', 'By', and 'Bz'
        info - dict, reference grid and other information"""

    #check the extension
    file_path = subcalc_funks._check_extension(file_path, 'REF', """
        SubCalc results are saved to text files with .REF extensions.
        The input path:
            "%s"
        does not have the correct extension.""" % file_path)

    #allocate dictionaries
    info = {'REF_path': file_path} #dictionary storing reference grid information
    keys = ['X Coord', 'Y Coord', 'X Mag', 'Y Mag', 'Z Mag', 'Max', 'Res']
    return_keys = ['x', 'y', 'bx', 'by', 'bz', 'bmax', 'bres']
    data = dict(zip(keys, [[] for i in range(len(keys))]))

    #pull data out
    with open(file_path, 'r') as ifile:
        #store information about the grid
        for i in range(24):
            line = ifile.readline().strip()
            if(':' in line):
                idx = line.find(':')
                line = [line[:idx], line[idx+1:]]
                if(subcalc_funks._is_number(line[1])):
                    if(subcalc_funks._is_int(line[1])):
                        info[line[0]] = int(float(line[1]))
                    else:
                        info[line[0]] = float(line[1])
                else:
                    info[line[0]] = line[1].strip()
        #read through the rest of the data
        for line in ifile:
            for k in keys:
                if(k == line[:len(k)]):
                    L = line[8:].rstrip()
                    data[k].append([float(L[i:i+8]) for i in range(0, len(L)-1, 8)])

    #flatten the lists in data
    for k in data:
        data[k] = np.array(subcalc_funks._flatten(data[k]))

    #switch the keys
    data = dict(zip(return_keys, [data[k] for k in keys]))

    return(data, info)
