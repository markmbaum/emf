from .. import os, np

import subcalc_funks
import subcalc_class

def convert_INP(file_path, **kw):
    """Convert a formatted SUBCALC file containing model input information in to an emf.subcalc tower template file. The target file must have an INP extension. These files are generated by the "Output > Ascii > Input Data" function in the SUBCALC program.
    args:
        file_path - string, path to the target INP file
    kw:
        path - string, output destination/filename"""

    subcalc_funks.load_towers(file_path, True).to_tower_template(**kw)

def read_INP(file_path):
    """Read a formatted SUBCALC file containing model input information and convert it to a list of emf.subcalc Tower objects. The target file must have an INP extension. These files are generated by the "Output > Ascii > Input Data" function in the SUBCALC program. To load an INP file directly in to a Model object, use the emf.subcalc.load_towers() function.
    args:
        file_path - string, path to the target INP file
    returns:
        a list of Towers"""

    #check extension
    subcalc_funks._check_extension(file_path.lower(), 'inp',
            'Target file must have an "INP" extension.')

    info = {}
    with open(file_path, 'r') as ifile:
        line = ifile.readline()
        #collect info
        while('Label:' not in line):
            if((':' in line) and ('World' not in line)):
                idx = line.index(':')
                info[line[:idx]] = line[idx+1:]
            line = ifile.readline()
        towers = []
        #read to the end of the file, collecting Towers
        while(line != ''):

            if('Label:' in line):
                #pull the group name for the tower group
                group = line[line.index(':')+1:].strip()[1:-1].replace('#','')
                #advance to the numbers
                while(not subcalc_funks._is_number(line[:5])):
                    line = ifile.readline()
                #now read to the end of the tower group, moving through the data
                seq, x, y, rot = None, None, None, None
                h, v, I, phase = [], [], [], []

                while(line[:6] != '______'):
                    #split the line
                    s = line.strip().split()
                    #check if the line defines tower seqence, x, y, and rot
                    if((len(s) == 4) or (len(s) == 5)):
                        #store previous tower if there is one and clear vars
                        if(seq is not None):
                            towers.append(subcalc_class.Tower(
                                    group, seq, x, y, rot, h, v, I, phase))
                            h, v, I, phase = [], [], [], []
                        #grab new tower info
                        seq, x, y, rot = [float(i) for i in s][:4]
                        rot -= 90

                    elif(len(s) == 6):
                        #wire information
                        d = [float(i) for i in s[-4:]]
                        h.append(d[0])
                        v.append(d[1])
                        I.append(d[2])
                        phase.append(d[3])

                    line = ifile.readline()

                #store the last Tower
                if(seq is not None):
                    towers.append(subcalc_class.Tower(
                            group, seq, x, y, rot, h, v, I, phase))

            line = ifile.readline()

        return(towers)

def convert_REF(*args, **kw):
    """Convert a .REF results file to an excel file storing the same data and save the excel file
    args:
        REF_path - string, path to the .REF file
        footprint_path - string, optional, path to footprint csv file
    kw:
        path - string, path/name of output file"""

    #load and export the results
    subcalc_funks.load_results(*args, **kw).export(**kw)

def read_REF(file_path, **kw):
    """Reads a .REF output file generated by the SUBCALC program, pulling out x and y coordinates for the results and all the magnetic field "components"
    args:
        file_path - string, path to saved .REF output file
    kw:
        delim - single character, if the REF file contains delimited
                output data (this is an option in SUBCALC), it will be
                detected automatically. In this case, the delimiter is
                assumed to be a comma and must be specified in the 'delim'
                argument if is something else.
    returns:
        data - dict of 2D numpy arrays, keys are 'X', 'Y', 'Bmax', 'Bres',
               'Bx', 'By', and 'Bz'
        info - dict, reference grid and other information"""

    #check the extension
    file_path = subcalc_funks._check_extension(file_path, 'REF', """
        SubCalc results are saved to text files with .REF extensions.
        The input path:
            "%s"
        does not have the correct extension.""" % file_path)

    #dictionary storing reference grid information
    info = {'REF_path': file_path}

    #pull data out
    with open(file_path, 'r') as ifile:
        #store information about the grid
        for i in range(24):
            line = ifile.readline().strip()
            if(':' in line):
                idx = line.find(':')
                line = [line[:idx], line[idx+1:]]
                if(subcalc_funks._is_number(line[1])):
                    if(subcalc_funks._is_int(line[1])):
                        info[line[0]] = int(float(line[1]))
                    else:
                        info[line[0]] = float(line[1])
                else:
                    info[line[0]] = line[1].strip()
        #see whether the file is formatted or delimited
        if('__________' in line):
            #it's formatted, parse the rest of the data
            keys = ['X Coord', 'Y Coord', 'X Mag', 'Y Mag', 'Z Mag', 'Max', 'Res']
            k2k = dict(zip(keys, ['X', 'Y', 'Bx', 'By', 'Bz', 'Bmax', 'Bres']))
            data = dict(zip(keys, [[] for i in range(len(keys))]))
            for line in ifile:
                for k in keys:
                    if(k == line[:len(k)]):
                        L = line[8:].rstrip()
                        data[k].append([float(L[i:i+8]) for i in range(0, len(L)-1, 8)])
            #flatten the lists in data
            for k in data:
                data[k] = np.array(subcalc_funks._flatten(data[k]))
            #swap keys
            data = {k2k[k]:data[k] for k in data}
            #mesh the grids
            data = _mesh_dict_grids(data)
        elif('Resultant' in line):
            #it's delimited, get the delimiter (comma by default)
            if('delim' in kw):
                delim = kw['delim']
            else:
                delim = ','
            #parse the rest of the data
            keys = ['Resultant', 'X Component', 'Y Component', 'Z Component',
                    'Maximum', 'X', 'Y']
            k2k = dict(zip(keys, ['Bres', 'Bx', 'By', 'Bz', 'Bmax', 'X', 'Y']))
            data = dict()
            while(line):
                #print line
                if(line.strip() in keys):
                    k = line.strip()
                    #read and split until an empty line
                    slines = [] #list of split lines
                    line = ifile.readline()
                    while(line.strip()):
                        slines.append(line.strip().split(delim)[:-1])
                        line = ifile.readline()
                    #parse the slines
                    if(('X' not in data) and ('Y' not in data)):
                        data['X'], data['Y'] = np.meshgrid(
                            [float(i) for i in slines[0][1:]],
                            [float(slines[i][0]) for i in range(1,len(slines))]
                        )
                    #trim off x and y values
                    slines = [sl[1:] for sl in slines[1:]]
                    #convert to numbers
                    slines = [[float(i) for i in sl] for sl in slines]
                    #convert to an array and add to the data dict
                    data[k] = np.array(slines)

                line = ifile.readline()
            #swap keys
            data = {k2k[k]:data[k] for k in data}

    return(data, info)

def _mesh_dict_grids(flat_data):
    """Convert raw grid data read from a SubCalc output file (by the read_REF function) into meshed grids of X, Y coordinates and their corresponding B field values.
    args:
        flat_data - dict, keyed by 'X', 'Y', 'Bx', 'By', 'Bz', 'Bmax', 'Bres'
    returns:
        grid_data - dict with 2D arrays with the same keys as flat_data"""
    #find the number of points in a row
    x = flat_data['X']
    y = flat_data['Y']
    count = 0
    v = y[0]
    while(y[count] == v):
        count += 1
    #get ncols and nrows
    L = len(x)
    ncols = count
    nrows = L/ncols
    #mesh the grids and return
    return({k:np.reshape(flat_data[k], (nrows, ncols)) for k in flat_data})
