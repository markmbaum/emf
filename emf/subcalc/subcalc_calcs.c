#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "subcalc_calcs.h"

double B_integral (double xp, double yp, double zp,
        double delta_x, double delta_y, double delta_z,
        double xa, double ya, double za) {
    /*This function returns the result of the path integral along a wire
    segment, which is needed to calculate the magnetic fields generated by it.
    The integrated function is common to all components of the magnetic field
    for a single point, so it is evaluated once and applied to each component.
    The integrated function is:

    [(xp - s*delta_x - xa)^2 + (yp - s*delta_y - ya)^2 + (zp - s*delta_z - za)^2]^(3.2)

    args:
        xp - the x coordinate of the sample location
        yp - the y coordinate of the sample location
        zp - the z coordinate of the sample location
        delta_x - the wire's change along the x dimension (xb - xa)
        delta_y - the wire's change along the y dimension (yb - ya)
        delta_z - the wire's change along the z dimension (zb - za)
        xa - the starting x coordinate of the wire
        ya - the starting y coordinate of the wire
        za - the starting z coordinate of the wire
    returns:
        result - the value of the path integral from s=0 to s=1*/

    double result;

    double lim_eq1_num, lim_eq1_sqrt, lim_eq0_num, lim_eq0_sqrt, body;

    double delta_x_sq = pow(delta_x, 2.0);
    double delta_y_sq = pow(delta_y, 2.0);
    double delta_z_sq = pow(delta_z, 2.0);

    double xa_sq = pow(xa, 2.0);
    double ya_sq = pow(ya, 2.0);
    double za_sq = pow(za, 2.0);

    double xp_sq = pow(xp, 2.0);
    double yp_sq = pow(yp, 2.0);
    double zp_sq = pow(zp, 2.0);

    //store the numerator of the integrated function, evaluated at 1
    lim_eq1_num = (delta_x_sq + delta_x*(xa - xp)
                + delta_y_sq + delta_y*(ya - yp)
                + delta_z*(delta_z + za - zp));

    //store a portion of the denominator of the integrated function,
    //evaluated at 1
    lim_eq1_sqrt = sqrt(delta_x_sq + 2*delta_x*xa - 2*delta_x*xp + xa_sq - 2*xa*xp
                + delta_y_sq + 2*delta_y*ya - 2*delta_y*yp + ya_sq - 2*ya*yp
                + delta_z_sq + 2*delta_z*za - 2*delta_z*zp + za_sq - 2*za*zp
                + xp_sq + yp_sq + zp_sq);

    //store the numerator of the integrated function, evaluated at 0
    lim_eq0_num = delta_x*(xa - xp) + delta_y*(ya - yp) + delta_z*(za - zp);

    //store a portion of the denominator of the integrated function,
    //evaluated at 0
    lim_eq0_sqrt = sqrt(xa_sq - 2*xa*xp
                + ya_sq - 2*ya*yp
                + za_sq - 2*za*zp
                + xp_sq + yp_sq + zp_sq);

    //store the other portion of the integrated function's denominator,
    //which is the same regardless of the evaluation value
    body = (delta_x_sq*(ya_sq - 2.0*ya*yp + za_sq
        - 2.0*za*zp + yp_sq + zp_sq) - 2.0*xa*(delta_x*(delta_y*ya - delta_y*yp
        + delta_z*za - delta_z*zp) + xp*(delta_y_sq + delta_z_sq))
        + 2.0*delta_x*xp*(delta_y*ya - delta_y*yp + delta_z*za - delta_z*zp)
        + xa_sq*(delta_y_sq + delta_z_sq) + delta_y_sq*za_sq
        - 2.0*delta_y_sq*za*zp + delta_y_sq*xp_sq + delta_y_sq*zp_sq
        - 2.0*delta_y*ya*delta_z*za + 2.0*delta_y*ya*delta_z*zp
        + 2.0*delta_y*delta_z*za*yp - 2.0*delta_y*delta_z*yp*zp
        + ya_sq*delta_z_sq - 2.0*ya*delta_z_sq*yp + delta_z_sq*xp_sq
        + delta_z_sq*yp_sq);

    //put it all together
    result = lim_eq1_num/(body*lim_eq1_sqrt) - lim_eq0_num/(body*lim_eq0_sqrt);

    return(result);

}

Results compute (double *x, double *y, double *z,
        double delta_x, double delta_y, double delta_z,
        double xa, double ya, double za,
        int Nx, int Ny, int Nz){
    /*This function does the heavy lifting neede to compute the magnetic
    field generated by a current carrying wire segment in 3d space, at a set
    of points in that 3d space. The wire runs from the point (xa, ya, za) to
    (xb, yb, zb).
    args:
        x - an array of unique x coordinates in the desired sample grid
        y - an array of unique y coordinates in the desired sample grid
        z - an array of unique z coordinates in the desired sample grid
        delta_x - the wire's change along the x dimension (xb - xa)
        delta_y - the wire's change along the y dimension (yb - ya)
        delta_z - the wire's change along the z dimension (zb - za)
        xa - the starting x coordinate of the wire
        ya - the starting y coordinate of the wire
        za - the starting z coordinate of the wire
        Nx - total number of x coordinates in the grid (length of x input)
        Ny - total number of y coordinates in the grid (length of y input)
        Nz - total number of z coordinates in the grid (length of z input)
    returns:
        res - a structure with four 1D arrays containing the results*/

    int i, j, k;
    int xidx, yidx, zidx;
    int idx;
    double xp, yp, zp;

    Results res;

    res.fac_x = (double *)malloc(Nx * Ny * Nz * sizeof(double));
    res.fac_y = (double *)malloc(Nx * Ny * Nz * sizeof(double));
    res.fac_z = (double *)malloc(Nx * Ny * Nz * sizeof(double));
    res.integral = (double *)malloc(Nx * Ny * Nz * sizeof(double));

    for (i = 0; i < Ny; i++) {
        for (j = 0; j < Nx; j++) {
            for (k = 0; k < Nz; k++) {
                //store the sample point's coordinates
                xp = x[j];
                yp = y[i];
                zp = z[k];
                //store the indices along each dimension as if there were
                //three dimensional arrays to work with
                xidx = j;
                yidx = Ny - i - 1;
                zidx = Nz - k - 1;
                //basically hash the indices and get a single index
                idx = k*Ny*Nx + j*Ny + i;
                //store the "fac" values, which are the components of a
                //three dimensional vector that will be scaled by the path
                //integral, the current, and the leading Biot-Savart constants
                res.fac_x[idx] = delta_y*(zp - za) + delta_z*(ya - yp);
                res.fac_y[idx] = delta_z*(xp - xa) + delta_x*(za - zp);
                res.fac_z[idx] = delta_z*(yp - ya) + delta_y*(xa - xp);
                //store the path integral value for this location
                res.integral[idx] = B_integral(xp, yp, zp, delta_x, delta_y, delta_z, za, ya, za);
            }
        }
    }
}

int main (void) {

    int i;

    int Nx = 1000;
    int Ny = 250;
    int Nz = 1;
    double x[Nx];
    double y[Ny];
    double z[Nz];
    double delta_x = 4.0;
    double delta_y = 5.0;
    double delta_z = 6.0;
    double xa = 7.0;
    double ya = 8.0;
    double za = 9.0;


    for (i = 0; i < Nx; i++) {
        x[i] = (float)i;
    };
    for (i = 0; i < Ny; i++) {
        y[i] = (float)i;
    };
    z[0] = 3.0;

    printf("computing...");
    compute(x, y, z,
            delta_x, delta_y, delta_z,
            xa, ya, za,
            Nx, Ny, Nz);
    printf("done");
}
