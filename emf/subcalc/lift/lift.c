#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "lift.h"

double B_integral (double xp, double yp, double zp,
        double delta_x, double delta_y, double delta_z,
        double xa, double ya, double za) {

    /*This function returns the result of the path integral along a wire
    segment, which is needed to calculate the magnetic fields generated by it.
    The integrated function is common to all components of the magnetic field
    for a single point, so it is evaluated once and applied to each component.
    The function to integrate is:

    [(xp - s*delta_x - xa)^2 + (yp - s*delta_y - ya)^2 + (zp - s*delta_z - za)^2]^(3/2)

    and the integrated function has the form:

    num/(body*sqrt)

    Only the num and sqrt portions depend on the limits of the integral.

    args:
        xp - the x coordinate of the sample location
        yp - the y coordinate of the sample location
        zp - the z coordinate of the sample location
        delta_x - the wire's change along the x dimension (xb - xa)
        delta_y - the wire's change along the y dimension (yb - ya)
        delta_z - the wire's change along the z dimension (zb - za)
        xa - the starting x coordinate of the wire
        ya - the starting y coordinate of the wire
        za - the starting z coordinate of the wire
    returns:
        result - the value of the path integral from s=0 to s=1*/

    double result;

    double lim_eq1_num, lim_eq1_sqrt, lim_eq0_num, lim_eq0_sqrt, body;

    double delta_x_sq = pow(delta_x, 2.0);
    double delta_y_sq = pow(delta_y, 2.0);
    double delta_z_sq = pow(delta_z, 2.0);

    double xa_sq = pow(xa, 2.0);
    double ya_sq = pow(ya, 2.0);
    double za_sq = pow(za, 2.0);

    double xp_sq = pow(xp, 2.0);
    double yp_sq = pow(yp, 2.0);
    double zp_sq = pow(zp, 2.0);

    /*store the numerator of the integrated function, evaluated at 1*/
    lim_eq1_num = (delta_x_sq + delta_x*(xa - xp)
                + delta_y_sq + delta_y*(ya - yp)
                + delta_z*(delta_z + za - zp));

    /*store a portion of the denominator of the integrated function,
    evaluated at 1*/
    lim_eq1_sqrt = sqrt(
                delta_x_sq + 2*delta_x*xa - 2*delta_x*xp + xa_sq - 2*xa*xp
                + delta_y_sq + 2*delta_y*ya - 2*delta_y*yp + ya_sq - 2*ya*yp
                + delta_z_sq + 2*delta_z*za - 2*delta_z*zp + za_sq - 2*za*zp
                + xp_sq + yp_sq + zp_sq);

    /*store the numerator of the integrated function, evaluated at 0*/
    lim_eq0_num = delta_x*(xa - xp) + delta_y*(ya - yp) + delta_z*(za - zp);

    /*store a portion of the denominator of the integrated function,
    evaluated at 0*/
    lim_eq0_sqrt = sqrt(
                xa_sq - 2*xa*xp
                + ya_sq - 2*ya*yp
                + za_sq - 2*za*zp
                + xp_sq + yp_sq + zp_sq);

    /*store the other portion of the integrated function's denominator,
    which is the same regardless of the evaluation value/point*/
    body = (delta_x_sq*(ya_sq - 2.0*ya*yp + za_sq
        - 2.0*za*zp + yp_sq + zp_sq) - 2.0*xa*(delta_x*(delta_y*ya - delta_y*yp
        + delta_z*za - delta_z*zp) + xp*(delta_y_sq + delta_z_sq))
        + 2.0*delta_x*xp*(delta_y*ya - delta_y*yp + delta_z*za - delta_z*zp)
        + xa_sq*(delta_y_sq + delta_z_sq) + delta_y_sq*za_sq
        - 2.0*delta_y_sq*za*zp + delta_y_sq*xp_sq + delta_y_sq*zp_sq
        - 2.0*delta_y*ya*delta_z*za + 2.0*delta_y*ya*delta_z*zp
        + 2.0*delta_y*delta_z*za*yp - 2.0*delta_y*delta_z*yp*zp
        + ya_sq*delta_z_sq - 2.0*ya*delta_z_sq*yp + delta_z_sq*xp_sq
        + delta_z_sq*yp_sq);

    /*put it all together*/
    result = lim_eq1_num/(body*lim_eq1_sqrt) - lim_eq0_num/(body*lim_eq0_sqrt);

    return(result);

}

void lift (double *x, double *y, double *z,
        double delta_x, double delta_y, double delta_z,
        double xa, double ya, double za, long N,
        double *fac_x, double *fac_y, double *fac_z,
        double *integral) {

    /*This function does the heavy lifting needed to compute the magnetic field
    generated by a current carrying wire segment at a set of points in 3d space.
    The points needn't form a grid. The wire runs from the point a to point b,
    or from (xa, ya, za) to (xb, yb, zb).

    args:
        x - the x coordinates of all the sample points
        y - the y coordinates of all the sample points
        z - the z coordinates of all the sample points
        delta_x - the wire's change along the x dimension (xb - xa)
        delta_y - the wire's change along the y dimension (yb - ya)
        delta_z - the wire's change along the z dimension (zb - za)
        xa - the starting x coordinate of the wire
        ya - the starting y coordinate of the wire
        za - the starting z coordinate of the wire
        N - the total number of sample points
        fac_x - array of doubles to be filled in with x component factors.
                This array is passed by reference, but is essentially a return
                variable.
        fac_y - array of doubles to be filled in with y component factors.
                This array is passed by reference, but is essentially a return
                variable.
        fac_z - array of doubles to be filled in with z component factors.
                This array is passed by reference, but is essentially a return
                variable.
        integral - array of doubles to be filled in with integral results.
                This array is passed by reference, but is essentially a return
                variable.*/

    int i;
    double xp, yp, zp;

    for (i = 0; i < N; i++) {

        /*store the sample point's coordinates*/
        xp = x[i];
        yp = y[i];
        zp = z[i];

        /*store the "fac" values, which are the components of a
        three dimensional vector that will be scaled by the path
        integral, the current, and the leading Biot-Savart constants*/
        fac_x[i] = delta_y*(zp - za) + delta_z*(ya - yp);
        fac_y[i] = delta_z*(xp - xa) + delta_x*(za - zp);
        fac_z[i] = delta_x*(yp - ya) + delta_y*(xa - xp);

        /*store the path integral value for this location*/
        integral[i] = B_integral(xp, yp, zp,
                                delta_x, delta_y, delta_z,
                                xa, ya, za);
    }
}
